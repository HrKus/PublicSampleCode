"0","Gaussian_process_01 <- file.path(""./Gaussian_process_01.stan"")"
"0","Gaussian_process_02 <- file.path(""./Gaussian_process_02.stan"")"
"0","mod01 <- cmdstan_model(Gaussian_process_01)"
"2","Model executable is up to date!
"
"0","mod02 <- cmdstan_model(Gaussian_process_02)"
"2","Model executable is up to date!
"
"0","mod01$print()"
"1","//"
"1","
"
"1","// This Stan program defines a simple model, with a"
"1","
"
"1","// vector of values 'y' modeled as normally distributed"
"1","
"
"1","// with mean 'mu' and standard deviation 'sigma'."
"1","
"
"1","//"
"1","
"
"1","// Learn more about model development with Stan at:"
"1","
"
"1","//"
"1","
"
"1","//    http://mc-stan.org/users/interfaces/rstan.html"
"1","
"
"1","//    https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started"
"1","
"
"1","//"
"1","
"
"1",""
"1","
"
"1","data {"
"1","
"
"1","   int<lower=1> N1;"
"1","
"
"1","   int<lower=1> N2;"
"1","
"
"1","   vector[N1] x1;"
"1","
"
"1","   vector[N1] y1;"
"1","
"
"1","   vector[N2] x2;"
"1","
"
"1","}"
"1","
"
"1",""
"1","
"
"1","transformed data {"
"1","
"
"1","   int<lower=1> N = N1 + N2;"
"1","
"
"1","   vector[N] x;"
"1","
"
"1","   vector[N] Mu;"
"1","
"
"1","   real vx;"
"1","
"
"1","   real delta = 1e-4;"
"1","
"
"1",""
"1","
"
"1","   for (n in 1:N1) x[n] = x1[n];"
"1","
"
"1","   for (n in 1:N2) x[N1 + n] = x2[n];"
"1","
"
"1","   for (i in 1:N) Mu[i] = 0;"
"1","
"
"1","   vx = variance(x);"
"1","
"
"1","}"
"1","
"
"1",""
"1","
"
"1","parameters {"
"1","
"
"1","   vector[N2] y2;"
"1","
"
"1","   vector<lower=0>[3] theta;"
"1","
"
"1","   "
"1","
"
"1","}"
"1","
"
"1",""
"1","
"
"1","model {"
"1","
"
"1","   matrix[N, N] Cov;"
"1","
"
"1","   vector[N] y;"
"1","
"
"1","   for (n in 1:N1) y[n] = y1[n];"
"1","
"
"1","   for (n in 1:N2) y[N1 + n] = y2[n];"
"1","
"
"1",""
"1","
"
"1","   "
"1","
"
"1","   for (i in 1:N)"
"1","
"
"1","      for (j in 1:N)"
"1","
"
"1","         Cov[i,j] = theta[1]*exp(-pow(x[i] - x[j],2)/(theta[2]*vx)) + (i==j ? theta[3] : 0.0);"
"1","
"
"1","         "
"1","
"
"1","   //for (i in 1:N)"
"1","
"
"1","      //for (j in 1:N)"
"1","
"
"1","         //Cov[i,j] = theta[1]*(1/(1 + theta[2]*pow(x[i] - x[j],2)/vx)) + (i==j ? theta[3] : 0.0);"
"1","
"
"1","   "
"1","
"
"1",""
"1","
"
"1","   y ~ multi_normal(Mu, Cov);"
"1","
"
"1","   theta ~ normal(0,1);"
"1","
"
"1","}"
"1","
"
"1",""
"1","
"
"0","mod02$print()"
"1","//"
"1","
"
"1","// This Stan program defines a simple model, with a"
"1","
"
"1","// vector of values 'y' modeled as normally distributed"
"1","
"
"1","// with mean 'mu' and standard deviation 'sigma'."
"1","
"
"1","//"
"1","
"
"1","// Learn more about model development with Stan at:"
"1","
"
"1","//"
"1","
"
"1","//    http://mc-stan.org/users/interfaces/rstan.html"
"1","
"
"1","//    https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started"
"1","
"
"1","//"
"1","
"
"1",""
"1","
"
"1","data {"
"1","
"
"1","   int N1;"
"1","
"
"1","   int D;"
"1","
"
"1","   vector[D] x1[N1];"
"1","
"
"1","   vector[N1] y1;"
"1","
"
"1","   int N2;"
"1","
"
"1","   vector[D] x2[N2];"
"1","
"
"1","   }"
"1","
"
"1","transformed data {"
"1","
"
"1","   real delta = 1e-9;"
"1","
"
"1","   int N = N1 + N2;"
"1","
"
"1","   vector[D] x[N];"
"1","
"
"1","   for (n1 in 1:N1) x[n1] = x1[n1];"
"1","
"
"1","   for (n2 in 1:N2) x[N1 + n2] = x2[n2];"
"1","
"
"1","}"
"1","
"
"1","parameters {"
"1","
"
"1","   real<lower=0> rho;"
"1","
"
"1","   real<lower=0> alpha;"
"1","
"
"1","   real<lower=0> sigma;"
"1","
"
"1","   vector[N] eta;"
"1","
"
"1","}"
"1","
"
"1","transformed parameters {"
"1","
"
"1","   vector[N] f;"
"1","
"
"1","   {"
"1","
"
"1","      matrix[N, N] L_K;"
"1","
"
"1","      matrix[N, N] K = cov_exp_quad(x, alpha, rho);"
"1","
"
"1","      // diagonal elements"
"1","
"
"1","      for (n in 1:N)"
"1","
"
"1","         K[n, n] = K[n, n] + delta;"
"1","
"
"1","      L_K = cholesky_decompose(K);"
"1","
"
"1","      f = L_K * eta;"
"1","
"
"1","   }"
"1","
"
"1","}"
"1","
"
"1","model {"
"1","
"
"1","   rho ~ inv_gamma(5, 5);"
"1","
"
"1","   alpha ~ normal(0, 1);"
"1","
"
"1","   sigma ~ normal(0, 1);"
"1","
"
"1","   eta ~ normal(0, 1);"
"1","
"
"1","   y1 ~ normal(f[1:N1], sigma);"
"1","
"
"1","}"
"1","
"
"1","generated quantities {"
"1","
"
"1","   vector[N2] y2;"
"1","
"
"1","   for (n2 in 1:N2)"
"1","
"
"1","      y2[n2] = normal_rng(f[N1 + n2], sigma);"
"1","
"
"1","}"
"1","
"
